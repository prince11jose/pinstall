#!/bin/bash

# PInstall Repository Manager
# Manages package repositories and provides search functionality

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m'

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_DIR="$SCRIPT_DIR/repositories"
CACHE_DIR="$HOME/.cache/pinstall"
REPO_CACHE="$CACHE_DIR/repositories"

print_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

print_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1"
    exit 1
}

print_header() {
    echo -e "${CYAN}$1${NC}"
}

show_usage() {
    cat << EOF
PInstall Repository Manager

Usage: $0 [COMMAND] [OPTIONS]

COMMANDS:
    search <query>          Search for packages
    list                    List all available packages
    info <package>          Show detailed package information
    update                  Update repository cache
    add-repo <url>          Add a new repository
    list-repos              List configured repositories
    categories              List package categories

OPTIONS:
    --json                  Output in JSON format
    --verbose               Verbose output
    --help                  Show this help message

Examples:
    $0 search go                    # Search for packages containing 'go'
    $0 list                         # List all packages
    $0 info go                      # Show Go package details
    $0 update                       # Update repository cache
    $0 categories                   # Show package categories
EOF
}

# Initialize cache directory
init_cache() {
    mkdir -p "$CACHE_DIR"
    mkdir -p "$REPO_CACHE"
}

# Update repository cache
update_repos() {
    print_info "Updating repository cache..."
    
    init_cache
    
    # Copy local repository files
    if [[ -d "$REPO_DIR" ]]; then
        cp -r "$REPO_DIR"/* "$REPO_CACHE/" 2>/dev/null || true
        print_success "Local repositories updated"
    fi
    
    # TODO: Download remote repositories
    # This would fetch from configured remote repositories
    
    print_success "Repository cache updated"
}

# Search packages
search_packages() {
    local query="$1"
    local json_output="$2"
    
    if [[ -z "$query" ]]; then
        print_error "Search query is required"
    fi
    
    if [[ ! -f "$REPO_CACHE/packages.yml" ]]; then
        print_warning "Repository cache not found. Updating..."
        update_repos
    fi
    
    print_header "Search Results for: $query"
    echo ""
    
    # Simple grep-based search for now
    # TODO: Implement proper YAML parsing
    if grep -qi "$query" "$REPO_CACHE/packages.yml"; then
        # Extract package names that match
        local packages
        packages=$(grep -A 20 -B 2 -i "$query" "$REPO_CACHE/packages.yml" | grep -E "^  [a-z]" | cut -d':' -f1 | tr -d ' ' | sort -u)
        
        if [[ -n "$packages" ]]; then
            echo -e "${GREEN}Found packages:${NC}"
            echo ""
            
            for package in $packages; do
                if [[ "$package" =~ ^[a-z] ]]; then
                    echo -e "  ${CYAN}$package${NC}"
                    # Extract description
                    local desc
                    desc=$(grep -A 5 "^  $package:" "$REPO_CACHE/packages.yml" | grep "description:" | cut -d'"' -f2)
                    if [[ -n "$desc" ]]; then
                        echo -e "    $desc"
                    fi
                    echo ""
                fi
            done
        else
            echo -e "${YELLOW}No packages found matching '$query'${NC}"
        fi
    else
        echo -e "${YELLOW}No packages found matching '$query'${NC}"
    fi
}

# List all packages
list_packages() {
    local json_output="$1"
    
    if [[ ! -f "$REPO_CACHE/packages.yml" ]]; then
        print_warning "Repository cache not found. Updating..."
        update_repos
    fi
    
    print_header "Available Packages"
    echo ""
    
    # Extract package names
    local packages
    packages=$(grep -E "^  [a-z].*:" "$REPO_CACHE/packages.yml" | cut -d':' -f1 | tr -d ' ' | sort)
    
    for package in $packages; do
        if [[ "$package" =~ ^[a-z] ]]; then
            echo -e "  ${CYAN}$package${NC}"
            # Extract description
            local desc
            desc=$(grep -A 5 "^  $package:" "$REPO_CACHE/packages.yml" | grep "description:" | cut -d'"' -f2)
            if [[ -n "$desc" ]]; then
                echo -e "    $desc"
            fi
            
            # Extract latest version
            local version
            version=$(grep -A 10 "^  $package:" "$REPO_CACHE/packages.yml" | grep "latest_version:" | cut -d'"' -f2)
            if [[ -n "$version" ]]; then
                echo -e "    ${GREEN}Latest version: $version${NC}"
            fi
            echo ""
        fi
    done
}

# Show package information
show_package_info() {
    local package="$1"
    local json_output="$2"
    
    if [[ -z "$package" ]]; then
        print_error "Package name is required"
    fi
    
    if [[ ! -f "$REPO_CACHE/packages.yml" ]]; then
        print_warning "Repository cache not found. Updating..."
        update_repos
    fi
    
    # Check if package exists
    if ! grep -q "^  $package:" "$REPO_CACHE/packages.yml"; then
        print_error "Package '$package' not found"
    fi
    
    print_header "Package Information: $package"
    echo ""
    
    # Extract package information
    local section
    section=$(sed -n "/^  $package:/,/^  [a-z]/p" "$REPO_CACHE/packages.yml" | head -n -1)
    
    # Parse and display information
    echo "$section" | while IFS= read -r line; do
        if [[ "$line" =~ name:.*\"(.*)\" ]]; then
            echo -e "${GREEN}Name:${NC} ${BASH_REMATCH[1]}"
        elif [[ "$line" =~ description:.*\"(.*)\" ]]; then
            echo -e "${GREEN}Description:${NC} ${BASH_REMATCH[1]}"
        elif [[ "$line" =~ homepage:.*\"(.*)\" ]]; then
            echo -e "${GREEN}Homepage:${NC} ${BASH_REMATCH[1]}"
        elif [[ "$line" =~ license:.*\"(.*)\" ]]; then
            echo -e "${GREEN}License:${NC} ${BASH_REMATCH[1]}"
        elif [[ "$line" =~ latest_version:.*\"(.*)\" ]]; then
            echo -e "${GREEN}Latest Version:${NC} ${BASH_REMATCH[1]}"
        elif [[ "$line" =~ lts_version:.*\"(.*)\" ]]; then
            echo -e "${GREEN}LTS Version:${NC} ${BASH_REMATCH[1]}"
        fi
    done
    
    echo ""
    echo -e "${GREEN}Supported Platforms:${NC}"
    
    # Extract platform information
    echo "$section" | grep -A 20 "platforms:" | grep -E "(linux|darwin|windows):" | while read -r platform; do
        local os
        os=$(echo "$platform" | cut -d':' -f1 | tr -d ' ')
        echo -e "  ${CYAN}$os${NC}"
    done
    
    echo ""
    echo -e "${GREEN}Available Versions:${NC}"
    
    # Extract versions
    local in_versions=false
    echo "$section" | while IFS= read -r line; do
        if [[ "$line" =~ versions: ]]; then
            in_versions=true
        elif [[ "$line" =~ ^[[:space:]]*- ]]; then
            if [[ "$in_versions" == true ]]; then
                local version
                version="${line##*- \"}"
                version="${version%\"*}"
                echo -e "  ${YELLOW}$version${NC}"
            fi
        elif [[ "$line" =~ ^[[:space:]]*[a-z] ]] && [[ "$in_versions" == true ]]; then
            break
        fi
    done
}

# List categories
list_categories() {
    local json_output="$1"
    
    if [[ ! -f "$REPO_CACHE/packages.yml" ]]; then
        print_warning "Repository cache not found. Updating..."
        update_repos
    fi
    
    print_header "Package Categories"
    echo ""
    
    # Extract categories
    local in_categories=false
    while IFS= read -r line; do
        if [[ "$line" =~ ^categories: ]]; then
            in_categories=true
            continue
        fi
        
        if [[ "$in_categories" == true ]]; then
            if [[ "$line" =~ ^[[:space:]]*([a-z_]+): ]]; then
                local category="${BASH_REMATCH[1]}"
                echo -e "${CYAN}$category${NC}"
            elif [[ "$line" =~ name:.*\"(.*)\" ]]; then
                echo -e "  Name: ${BASH_REMATCH[1]}"
            elif [[ "$line" =~ description:.*\"(.*)\" ]]; then
                echo -e "  Description: ${BASH_REMATCH[1]}"
            elif [[ "$line" =~ packages: ]]; then
                echo -e "  ${GREEN}Packages:${NC}"
            elif [[ "$line" =~ -[[:space:]]+\"(.*)\" ]]; then
                echo -e "    - ${YELLOW}${BASH_REMATCH[1]}${NC}"
                echo ""
            fi
        fi
    done < "$REPO_CACHE/packages.yml"
}

# List repositories
list_repos() {
    print_header "Configured Repositories"
    echo ""
    
    if [[ ! -f "$REPO_CACHE/packages.yml" ]]; then
        print_warning "Repository cache not found. Updating..."
        update_repos
    fi
    
    # Extract repository information
    local in_repos=false
    while IFS= read -r line; do
        if [[ "$line" =~ ^repositories: ]]; then
            in_repos=true
            continue
        fi
        
        if [[ "$in_repos" == true ]]; then
            if [[ "$line" =~ ^[[:space:]]*([a-z_]+): ]]; then
                local repo="${BASH_REMATCH[1]}"
                echo -e "${CYAN}$repo${NC}"
            elif [[ "$line" =~ name:.*\"(.*)\" ]]; then
                echo -e "  Name: ${BASH_REMATCH[1]}"
            elif [[ "$line" =~ description:.*\"(.*)\" ]]; then
                echo -e "  Description: ${BASH_REMATCH[1]}"
            elif [[ "$line" =~ url:.*\"(.*)\" ]]; then
                echo -e "  URL: ${BASH_REMATCH[1]}"
            elif [[ "$line" =~ enabled:.*true ]]; then
                echo -e "  Status: ${GREEN}Enabled${NC}"
                echo ""
            elif [[ "$line" =~ enabled:.*false ]]; then
                echo -e "  Status: ${RED}Disabled${NC}"
                echo ""
            elif [[ "$line" =~ ^packages: ]]; then
                break
            fi
        fi
    done < "$REPO_CACHE/packages.yml"
}

# Main function
main() {
    local command=""
    local json_output=false
    # local verbose=false  # TODO: Implement verbose functionality
    local query=""
    local package=""
    # local repo_url=""  # TODO: Implement repo URL functionality
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            search)
                command="search"
                shift
                query="$1"
                shift
                ;;
            list)
                command="list"
                shift
                ;;
            info)
                command="info"
                shift
                package="$1"
                shift
                ;;
            update)
                command="update"
                shift
                ;;
            add-repo)
                command="add-repo"
                shift
                # repo_url="$1"  # TODO: Implement add-repo functionality
                shift
                ;;
            list-repos)
                command="list-repos"
                shift
                ;;
            categories)
                command="categories"
                shift
                ;;
            --json)
                json_output=true
                shift
                ;;
            --verbose)
                # verbose=true  # TODO: Implement verbose output
                shift
                ;;
            --help)
                show_usage
                exit 0
                ;;
            *)
                print_error "Unknown option: $1"
                ;;
        esac
    done
    
    if [[ -z "$command" ]]; then
        show_usage
        exit 1
    fi
    
    case "$command" in
        search)
            search_packages "$query" "$json_output"
            ;;
        list)
            list_packages "$json_output"
            ;;
        info)
            show_package_info "$package" "$json_output"
            ;;
        update)
            update_repos
            ;;
        list-repos)
            list_repos
            ;;
        categories)
            list_categories "$json_output"
            ;;
        *)
            print_error "Unknown command: $command"
            ;;
    esac
}

main "$@"
