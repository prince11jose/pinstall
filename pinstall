#!/bin/bash

# PInstall - Cross-Platform Package Installer
# Author: MovingWalls Personal
# Version: 1.0.0

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Global variables
OS=""
DISTRO=""
ARCH=""
APP=""
VERSION=""
INSTALL_DIR=""
TEMP_DIR="/tmp/pinstall"

# Function to print colored output
print_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

print_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1"
    exit 1
}

# Function to show usage
show_usage() {
    cat << EOF
PInstall - Cross-Platform Package Installer

Usage: $0 [OPTIONS]

REQUIRED OPTIONS:
    --app=<name>           Application to install (go, node, python, docker, git)
    --ver=<version>        Version to install

SEARCH AND INFO OPTIONS:
    --search=<query>       Search for available packages
    --info=<package>       Show detailed package information
    --list                 List all available packages

OPTIONAL OPTIONS (auto-detected if not specified):
    --dry-run             Show what would be done without executing
    --linux                Target Linux operating system
    --mac                  Target macOS operating system
    --ubuntu               Ubuntu distribution (requires --linux)
    --amzn2023            Amazon Linux 2023 (requires --linux)
    --centos              CentOS distribution (requires --linux)
    --debian              Debian distribution (requires --linux)
    --x64                 x86_64 architecture
    --arm64               ARM64 architecture
    --x86                 x86 architecture
    --help                Show this help message

Examples:
    $0 --app=go --ver=1.24.4                                    # Auto-detect everything
    $0 --app=node --ver=20.10.0 --x64                          # Specify only architecture
    $0 --search=python                                          # Search for packages
    $0 --info=go                                                # Show package info
    $0 --list                                                   # List all packages
    $0 --linux --ubuntu --x64 --app=go --ver=1.24.4           # Specify everything manually
    $0 --linux --amzn2023 --arm64 --app=node --ver=20.10.0    # Amazon Linux ARM64

Supported Applications:
    - go: Go programming language
    - node: Node.js runtime
    - python: Python interpreter
    - docker: Docker container platform
    - git: Git version control system
EOF
}

# Function to parse command line arguments
parse_args() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            --dry-run)
                DRY_RUN=true
                shift
                ;;
            --search=*)
                SEARCH_TERM="${1#*=}"
                shift
                ;;
            --info=*)
                INFO_PACKAGE="${1#*=}"
                shift
                ;;
            --list)
                LIST_PACKAGES=true
                shift
                ;;
            --linux)
                OS="linux"
                shift
                ;;
            --mac)
                OS="mac"
                shift
                ;;
            --ubuntu)
                DISTRO="ubuntu"
                shift
                ;;
            --amzn2023)
                DISTRO="amzn2023"
                shift
                ;;
            --centos)
                DISTRO="centos"
                shift
                ;;
            --debian)
                DISTRO="debian"
                shift
                ;;
            --x64)
                ARCH="x64"
                shift
                ;;
            --arm64)
                ARCH="arm64"
                shift
                ;;
            --x86)
                ARCH="x86"
                shift
                ;;
            --app=*)
                APP="${1#*=}"
                shift
                ;;
            --ver=*)
                VERSION="${1#*=}"
                shift
                ;;
            --help)
                show_usage
                exit 0
                ;;
            *)
                print_error "Unknown option: $1"
                ;;
        esac
    done
}

# Function to validate arguments
validate_args() {
    # Handle search/info/list commands first
    if [[ -n "$SEARCH_TERM" ]]; then
        ./repo-manager search "$SEARCH_TERM"
        exit 0
    fi
    
    if [[ -n "$INFO_PACKAGE" ]]; then
        ./repo-manager info "$INFO_PACKAGE"
        exit 0
    fi
    
    if [[ "$LIST_PACKAGES" == true ]]; then
        ./repo-manager list
        exit 0
    fi
    
    # Validate installation arguments
    if [[ -z "$APP" ]]; then
        print_error "Application not specified. Use --app=<name>"
    fi

    if [[ -z "$VERSION" ]]; then
        print_error "Version not specified. Use --ver=<version>"
    fi
}

# Function to detect system if not specified
detect_system() {
    # Auto-detect OS if not specified
    if [[ -z "$OS" ]]; then
        case "$(uname -s)" in
            Linux*)     OS="linux";;
            Darwin*)    OS="mac";;
            *)          print_error "Unsupported operating system: $(uname -s)";;
        esac
        print_info "Auto-detected OS: $OS"
    fi

    # Auto-detect Linux distribution if not specified
    if [[ "$OS" == "linux" && -z "$DISTRO" ]]; then
        if [[ -f /etc/os-release ]]; then
            # Save VERSION before sourcing os-release to avoid overwriting it
            local saved_version="$VERSION"
            # shellcheck source=/dev/null
            . /etc/os-release
            # Restore VERSION after sourcing
            VERSION="$saved_version"
            
            case "$ID" in
                ubuntu) DISTRO="ubuntu";;
                amzn) DISTRO="amzn2023";;
                centos|rhel) DISTRO="centos";;
                debian) DISTRO="debian";;
                *) print_warning "Unknown distribution: $ID, defaulting to ubuntu"
                   DISTRO="ubuntu";;
            esac
        else
            print_warning "Cannot detect distribution, defaulting to ubuntu"
            DISTRO="ubuntu"
        fi
        print_info "Auto-detected distribution: $DISTRO"
    fi

    # Auto-detect architecture if not specified
    if [[ -z "$ARCH" ]]; then
        case "$(uname -m)" in
            x86_64) ARCH="x64";;
            aarch64|arm64) ARCH="arm64";;
            i386|i686) ARCH="x86";;
            armv7l) ARCH="arm";;
            *) print_error "Unsupported architecture: $(uname -m)";;
        esac
        print_info "Auto-detected architecture: $ARCH"
    fi
}

# Function to setup installation directory
setup_install_dir() {
    case "$OS" in
        linux|mac)
            INSTALL_DIR="$HOME/.local"
            ;;
        *)
            print_error "Unsupported OS: $OS"
            ;;
    esac

    mkdir -p "$INSTALL_DIR/bin"
    mkdir -p "$TEMP_DIR"
}

# Function to update PATH in shell profiles
update_path() {
    local bin_dir="$INSTALL_DIR/bin"
    local profile_files=("$HOME/.bashrc" "$HOME/.zshrc" "$HOME/.profile")
    
    for profile in "${profile_files[@]}"; do
        if [[ -f "$profile" ]]; then
            if ! grep -q "$bin_dir" "$profile"; then
                {
                    echo ""
                    echo "# Added by pinstall"
                    echo "export PATH=\"$bin_dir:\$PATH\""
                } >> "$profile"
                print_info "Updated PATH in $profile"
            fi
        fi
    done
}

# Function to set environment variables for specific apps
set_env_vars() {
    local app="$1"
    local install_path="$2"
    local profile_files=("$HOME/.bashrc" "$HOME/.zshrc" "$HOME/.profile")
    
    case "$app" in
        go)
            for profile in "${profile_files[@]}"; do
                if [[ -f "$profile" ]]; then
                    if ! grep -q "GOROOT" "$profile"; then
                        {
                            echo "export GOROOT=\"$install_path\""
                            echo "export GOPATH=\"\$HOME/go\""
                            echo "export PATH=\"\$GOROOT/bin:\$GOPATH/bin:\$PATH\""
                        } >> "$profile"
                        print_info "Set Go environment variables in $profile"
                    fi
                fi
            done
            ;;
        node)
            for profile in "${profile_files[@]}"; do
                if [[ -f "$profile" ]]; then
                    if ! grep -q "NODE_HOME" "$profile"; then
                        {
                            echo "export NODE_HOME=\"$install_path\""
                            echo "export PATH=\"\$NODE_HOME/bin:\$PATH\""
                        } >> "$profile"
                        print_info "Set Node.js environment variables in $profile"
                    fi
                fi
            done
            ;;
        python)
            for profile in "${profile_files[@]}"; do
                if [[ -f "$profile" ]]; then
                    if ! grep -q "PYTHON_HOME" "$profile"; then
                        {
                            echo "export PYTHON_HOME=\"$install_path\""
                            echo "export PATH=\"\$PYTHON_HOME/bin:\$PATH\""
                        } >> "$profile"
                        print_info "Set Python environment variables in $profile"
                    fi
                fi
            done
            ;;
    esac
}

# Function to install Go
install_go() {
    local version="$1"
    local os_name arch_name download_url filename install_path
    
    case "$OS" in
        linux) os_name="linux";;
        mac) os_name="darwin";;
        *) print_error "Unsupported OS for Go: $OS";;
    esac
    
    case "$ARCH" in
        x64) arch_name="amd64";;
        arm64) arch_name="arm64";;
        x86) arch_name="386";;
        *) print_error "Unsupported architecture for Go: $ARCH";;
    esac
    
    filename="go${version}.${os_name}-${arch_name}.tar.gz"
    download_url="https://golang.org/dl/${filename}"
    install_path="$INSTALL_DIR/go-${version}"
    
    if [[ "$DRY_RUN" == true ]]; then
        print_info "[DRY RUN] Would download Go ${version} for ${os_name}-${arch_name}"
        print_info "[DRY RUN] Would download from: $download_url"
        print_info "[DRY RUN] Would install to: $install_path"
        print_info "[DRY RUN] Would create symlinks in $INSTALL_DIR/bin"
        print_info "[DRY RUN] Would set environment variables"
        print_success "[DRY RUN] Go ${version} installation simulated"
        return
    fi
    
    print_info "Downloading Go ${version} for ${os_name}-${arch_name}"
    curl -fsSL "$download_url" -o "$TEMP_DIR/$filename"
    
    print_info "Installing Go to $install_path"
    mkdir -p "$install_path"
    tar -C "$install_path" --strip-components=1 -xzf "$TEMP_DIR/$filename"
    
    # Create symlink to current version
    ln -sf "$install_path" "$INSTALL_DIR/go"
    ln -sf "$install_path/bin/go" "$INSTALL_DIR/bin/go"
    ln -sf "$install_path/bin/gofmt" "$INSTALL_DIR/bin/gofmt"
    
    set_env_vars "go" "$install_path"
    print_success "Go ${version} installed successfully"
}

# Function to install Node.js
install_node() {
    local version="$1"
    local os_name arch_name download_url filename install_path
    
    case "$OS" in
        linux) os_name="linux";;
        mac) os_name="darwin";;
        *) print_error "Unsupported OS for Node.js: $OS";;
    esac
    
    case "$ARCH" in
        x64) arch_name="x64";;
        arm64) arch_name="arm64";;
        x86) arch_name="x86";;
        *) print_error "Unsupported architecture for Node.js: $ARCH";;
    esac
    
    filename="node-v${version}-${os_name}-${arch_name}.tar.xz"
    download_url="https://nodejs.org/dist/v${version}/${filename}"
    install_path="$INSTALL_DIR/node-${version}"
    
    if [[ "$DRY_RUN" == true ]]; then
        print_info "[DRY RUN] Would download Node.js ${version} for ${os_name}-${arch_name}"
        print_info "[DRY RUN] Would download from: $download_url"
        print_info "[DRY RUN] Would install to: $install_path"
        print_info "[DRY RUN] Would create symlinks in $INSTALL_DIR/bin"
        print_info "[DRY RUN] Would set environment variables"
        print_success "[DRY RUN] Node.js ${version} installation simulated"
        return
    fi
    
    print_info "Downloading Node.js ${version} for ${os_name}-${arch_name}"
    curl -fsSL "$download_url" -o "$TEMP_DIR/$filename"
    
    print_info "Installing Node.js to $install_path"
    mkdir -p "$install_path"
    tar -C "$install_path" --strip-components=1 -xJf "$TEMP_DIR/$filename"
    
    # Create symlinks to current version
    ln -sf "$install_path" "$INSTALL_DIR/node"
    ln -sf "$install_path/bin/node" "$INSTALL_DIR/bin/node"
    ln -sf "$install_path/bin/npm" "$INSTALL_DIR/bin/npm"
    ln -sf "$install_path/bin/npx" "$INSTALL_DIR/bin/npx"
    
    set_env_vars "node" "$install_path"
    print_success "Node.js ${version} installed successfully"
}

# Function to install Python
install_python() {
    print_info "Installing Python ${VERSION}"
    
    if [[ "$DRY_RUN" == true ]]; then
        print_info "[DRY RUN] Would install Python ${VERSION} for distribution: $DISTRO"
        case "$DISTRO" in
            ubuntu|debian)
                print_info "[DRY RUN] Would run: sudo apt update"
                print_info "[DRY RUN] Would run: sudo apt install -y software-properties-common"
                print_info "[DRY RUN] Would run: sudo add-apt-repository -y ppa:deadsnakes/ppa"
                print_info "[DRY RUN] Would run: sudo apt install -y python${VERSION} python${VERSION}-pip python${VERSION}-venv"
                ;;
            amzn2023|centos)
                print_info "[DRY RUN] Would run: sudo yum update -y"
                print_info "[DRY RUN] Would run: sudo yum install -y python${VERSION} python${VERSION}-pip"
                ;;
            *)
                print_error "Python installation not supported for distribution: $DISTRO"
                ;;
        esac
        print_success "[DRY RUN] Python ${VERSION} installation simulated"
        return
    fi
    
    case "$DISTRO" in
        ubuntu|debian)
            sudo apt update
            sudo apt install -y software-properties-common
            sudo add-apt-repository -y ppa:deadsnakes/ppa
            sudo apt update
            sudo apt install -y "python${VERSION}" "python${VERSION}-pip" "python${VERSION}-venv"
            ;;
        amzn2023|centos)
            sudo yum update -y
            sudo yum install -y "python${VERSION}" "python${VERSION}-pip"
            ;;
        *)
            print_error "Python installation not supported for distribution: $DISTRO"
            ;;
    esac
    
    print_success "Python ${VERSION} installed successfully"
}

# Function to install Docker
install_docker() {
    print_info "Installing Docker"
    
    if [[ "$DRY_RUN" == true ]]; then
        print_info "[DRY RUN] Would install Docker for distribution: $DISTRO"
        case "$DISTRO" in
            ubuntu)
                print_info "[DRY RUN] Would run: sudo apt update"
                print_info "[DRY RUN] Would install prerequisites and Docker GPG key"
                print_info "[DRY RUN] Would add Docker repository"
                print_info "[DRY RUN] Would install Docker CE packages"
                ;;
            amzn2023)
                print_info "[DRY RUN] Would run: sudo yum update -y"
                print_info "[DRY RUN] Would run: sudo yum install -y docker"
                ;;
            centos)
                print_info "[DRY RUN] Would install yum-utils and Docker repository"
                print_info "[DRY RUN] Would install Docker CE packages"
                ;;
            debian)
                print_info "[DRY RUN] Would run: sudo apt update"
                print_info "[DRY RUN] Would install prerequisites and Docker GPG key"
                print_info "[DRY RUN] Would add Docker repository"
                print_info "[DRY RUN] Would install Docker CE packages"
                ;;
            *)
                print_error "Docker installation not supported for distribution: $DISTRO"
                ;;
        esac
        print_info "[DRY RUN] Would start and enable Docker service"
        print_info "[DRY RUN] Would add user to docker group"
        print_success "[DRY RUN] Docker installation simulated"
        return
    fi
    
    case "$DISTRO" in
        ubuntu)
            sudo apt update
            sudo apt install -y apt-transport-https ca-certificates curl gnupg lsb-release
            curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg
            echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
            sudo apt update
            sudo apt install -y docker-ce docker-ce-cli containerd.io
            ;;
        amzn2023)
            sudo yum update -y
            sudo yum install -y docker
            ;;
        centos)
            sudo yum install -y yum-utils
            sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo
            sudo yum install -y docker-ce docker-ce-cli containerd.io
            ;;
        debian)
            sudo apt update
            sudo apt install -y apt-transport-https ca-certificates curl gnupg lsb-release
            curl -fsSL https://download.docker.com/linux/debian/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg
            echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/debian $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
            sudo apt update
            sudo apt install -y docker-ce docker-ce-cli containerd.io
            ;;
        *)
            print_error "Docker installation not supported for distribution: $DISTRO"
            ;;
    esac
    
    sudo systemctl start docker
    sudo systemctl enable docker
    sudo usermod -aG docker "$USER"
    
    print_success "Docker installed successfully"
    print_info "Please log out and log back in for Docker group membership to take effect"
}

# Function to install Git
install_git() {
    print_info "Installing Git"
    
    if [[ "$DRY_RUN" == true ]]; then
        print_info "[DRY RUN] Would install Git for distribution: $DISTRO"
        case "$DISTRO" in
            ubuntu|debian)
                print_info "[DRY RUN] Would run: sudo apt update"
                print_info "[DRY RUN] Would run: sudo apt install -y git"
                ;;
            amzn2023|centos)
                print_info "[DRY RUN] Would run: sudo yum update -y"
                print_info "[DRY RUN] Would run: sudo yum install -y git"
                ;;
            *)
                print_error "Git installation not supported for distribution: $DISTRO"
                ;;
        esac
        print_success "[DRY RUN] Git installation simulated"
        return
    fi
    
    case "$DISTRO" in
        ubuntu|debian)
            sudo apt update
            sudo apt install -y git
            ;;
        amzn2023|centos)
            sudo yum update -y
            sudo yum install -y git
            ;;
        *)
            print_error "Git installation not supported for distribution: $DISTRO"
            ;;
    esac
    
    print_success "Git installed successfully"
}

# Main installation function
install_app() {
    case "$APP" in
        go)
            install_go "$VERSION"
            ;;
        node)
            install_node "$VERSION"
            ;;
        python)
            install_python
            ;;
        docker)
            install_docker
            ;;
        git)
            install_git
            ;;
        *)
            print_error "Unsupported application: $APP"
            ;;
    esac
}

# Cleanup function
cleanup() {
    if [[ -d "$TEMP_DIR" ]]; then
        rm -rf "$TEMP_DIR"
        print_info "Cleaned up temporary files"
    fi
}

# Main function
main() {
    print_info "PInstall - Cross-Platform Package Installer"
    
    parse_args "$@"
    validate_args
    detect_system
    setup_install_dir
    
    print_info "Target: $OS/$DISTRO $ARCH"
    print_info "Installing: $APP version $VERSION"
    
    install_app
    update_path
    cleanup
    
    print_success "Installation completed successfully!"
    print_info "Please restart your shell or run 'source ~/.bashrc' to use the installed application"
}

# Set trap for cleanup on exit
trap cleanup EXIT

# Run main function if script is executed directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
